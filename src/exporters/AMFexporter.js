/*
@author kaosat-dev 
resulting js will be cleaned up , and contributed to three.js
*/

/*
  var THREE, XMLWriter;
  THREE = require('three');
*/
//dependency... get rid of it ?
var XMLWriter = require('XMLWriter');

THREE.AMFExporter = function (generatorName, unit) {
	this.generatorName = generatorName || 'Generated by coffeescad' ;
	this.unit = unit || 'mm';
};

THREE.AMFExporter.prototype = {
    constructor: THREE.AMFExporter,

    _writeColor: function(xw, element) {
      xw.writeStartElement("color");
      xw.writeElementString("r", String(element.material.color[0]));
      xw.writeElementString("g", String(element.material.color[1]));
      xw.writeElementString("b", String(element.material.color[2]));
      xw.writeElementString("a", "0");
      return xw.writeEndElement();
    },
    _writeMaterials: function(writer, materials) {
      var index, material, _i, _len;
      writer.writeStartElement("materials");
      for (index = _i = 0, _len = materials.length; _i < _len; index = ++_i) {
        material = materials[index];
        this._writeMaterial(writer, material);
      }
      return writer.writeEndElement();
    },
    _writeMaterial: function(writer, material) {
      writer.writeStartElement("material");
      this._writeMetaData(writer, "Name", material.name);
      return writer.writeEndElement();
    },
    _writeTexture: function(writer, texture) {
      writer.writeStartElement("materials");
      return writer.writeEndElement();
    },
    _writeConstellation: function(writer, hierarchy) {
      var child, id, _i, _len, _ref;
      writer.writeStartElement("constellation");
      writer.writeAttributeString("id", "1");
      _ref = hierarchy.children;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        id = child.id;
        writer.writeStartElement("instance");
        writer.writeAttributeString("objectid", "" + id);
        writer.writeElementString("deltax", "" + child.position.x);
        writer.writeElementString("deltay", "" + child.position.x);
        writer.writeElementString("deltaz", "" + child.position.x);
        writer.writeElementString("rx", "" + child.rotation.x);
        writer.writeElementString("ry", "" + child.rotation.x);
        writer.writeElementString("rz", "" + child.rotation.x);
        writer.writeEndElement();
      }
      return writer.writeEndElement();
    },
    _writeObject: function(writer, object) {
      var id;
      id = object.id;
      writer.writeStartElement("object");
      writer.writeAttributeString("id", "" + id);
      if (object.name != null) {
        if (object.name !== "") {
          this._writeMetaData(writer, "name", "" + object.name);
        }
      }
      this._writeMesh(writer, object);
      return writer.writeEndElement();
    },
    _writeMesh: function(writer, mesh) {
      var geometry;
      geometry = mesh.geometry;
      writer.writeStartElement("mesh");
      this._writeVertices(writer, geometry.vertices);
      this._writeVolumes(writer, geometry.faces);
      return writer.writeEndElement();
    },
    _writeVertices: function(writer, vertices) {
      var vertex, _i, _len;
      writer.writeStartElement("vertices");
      for (_i = 0, _len = vertices.length; _i < _len; _i++) {
        vertex = vertices[_i];
        this._writeVertexNode(writer, vertex);
      }
      return writer.writeEndElement();
    },
    _writeVertexNode: function(writer, vertex) {
      writer.writeStartElement("vertex");
      writer.writeStartElement("coordinates");
      writer.writeElementString("x", "" + vertex.x);
      writer.writeElementString("y", "" + vertex.y);
      writer.writeElementString("z", "" + vertex.z);
      writer.writeEndElement();
      return writer.writeEndElement();
    },
    _writeVolumes: function(writer, faces) {
      var face, _i, _len;
      writer.writeStartElement("volume");
      for (_i = 0, _len = faces.length; _i < _len; _i++) {
        face = faces[_i];
        this._writeTriangle(writer, face);
      }
      return writer.writeEndElement();
    },
    _writeTriangle: function(writer, face) {
      if (face instanceof THREE.Face3) {
        writer.writeStartElement("triangle");
        writer.writeElementString("v1", "" + face.a);
        writer.writeElementString("v2", "" + face.b);
        writer.writeElementString("v3", "" + face.c);
        return writer.writeEndElement();
      } else if (face instanceof THREE.Face4) {
        writer.writeStartElement("triangle");
        writer.writeElementString("v1", "" + face.a);
        writer.writeElementString("v2", "" + face.b);
        writer.writeElementString("v3", "" + face.c);
        writer.writeEndElement();
        writer.writeStartElement("triangle");
        writer.writeElementString("v1", "" + face.c);
        writer.writeElementString("v2", "" + face.d);
        writer.writeElementString("v3", "" + face.a);
        return writer.writeEndElement();
      }
    },
    _writeMetaData: function(writer, type, data) {
      if (type == null) {
        type = "cad";
      }
      if (data == null) {
        data = "Generated by three.js";
      }
      writer.writeStartElement("metadata");
      writer.writeAttributeString("type", "" + type);
      writer.writeString(data);
      return writer.writeEndElement();
    },
	getTransformedPosition : function (vertex, matrix, position) {
		//from stl exporter
		var result = vertex.clone ();
		if (matrix !== undefined) {
			result.applyMatrix4 (matrix);
		}
		if (position !== undefined) {
			result.add (position);
		}
		return result;
	},

    parse: function(object) {
      var index, part, result, writer, _i, _len, _ref;
      console.log(object);
      unit = "milimeter";
      writer = new XMLWriter('UTF-8', '1.0');
      writer.writeStartDocument();
      writer.writeStartElement("amf");
      this._writeMetaData(writer, "cad", this.generatorName);
      writer.writeAttributeString("unit", this.unit);
      this._writeMaterials(writer, []);
      _ref = object.children;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        part = _ref[index];
        this._writeObject(writer, part);
      }
      this._writeConstellation(writer, object);
      writer.writeEndDocument();
      result = writer.flush();
      return result;
    }
};



